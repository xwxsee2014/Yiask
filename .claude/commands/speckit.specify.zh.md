---
description: 从自然语言功能描述创建或更新功能规范
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前**必须**考虑用户输入（如果不为空）。

## 概述

用户在触发消息中 `/speckit.specify` 后输入的文本**就是**功能描述。即使下面 `$ARGUMENTS` 出现字面意思，也要假设你在这段对话中始终可以获得它。除非用户提供了空命令，否则不要要求用户重复。

给定该功能描述，请执行以下操作：

1. **生成简洁的短名称**（2-4个单词）用于分支：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个2-4个单词的短名称，捕捉功能的本质
   - 可能时使用动作-名词格式（例如，"add-user-auth", "fix-payment-bug"）
   - 保留技术术语和缩写（OAuth2、API、JWT等）
   - 保持简洁但描述性足够，以便一目了然地理解功能
   - 示例：
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. **在创建新分支之前检查现有分支**：

   a. 首先，获取所有远程分支以确保我们拥有最新信息：
      ```bash
      git fetch --all --prune
      ```

   b. 找到所有来源中短名称的最高功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 规范目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录

   c. 确定下一个可用编号：
      - 从所有三个来源提取所有编号
      - 找到最高编号 N
      - 为新分支编号使用 N+1

   d. 使用计算出的编号和短名称运行脚本 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"`：
      - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
      - Bash 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 检查所有三个来源（远程分支、本地分支、规范目录）以找到最高编号
   - 只匹配具有确切短名称模式的分支/目录
   - 如果没有找到此短名称的现有分支/目录，从编号1开始
   - 每个功能必须只运行此脚本一次
   - JSON在终端中作为输出提供 - 始终引用它以获取你正在寻找的实际内容
   - JSON输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于带单引号的参数如"I'm Groot"，使用转义语法：例如 'I'\''m Groot'（如果可能使用双引号："I'm Groot"）

3. 加载 `.specify/templates/spec-template.md` 以了解所需的章节。

4. 遵循此执行流程：

   1. 从输入中解析用户描述
      如果为空：错误"未提供功能描述"
   2. 从描述中提取关键概念
      识别：参与者、动作、数据、约束
   3. 对于不明确的方面：
      - 基于上下文和行业标准做出明智的猜测
      - 仅在以下情况下标记为 [NEEDS CLARIFICATION: specific question]：
        - 选择显著影响功能范围或用户体验
        - 存在多个具有不同含义的合理解释
        - 没有合理的默认值
      - **限制：最多3个 [NEEDS CLARIFICATION] 标记总计**
      - 按影响优先考虑澄清：范围 > 安全/隐私 > 用户体验 > 技术细节
   4. 填写用户场景和测试章节
      如果没有明确的用户流程：错误"无法确定用户场景"
   5. 生成功能需求
      每个需求必须可测试
      对未指定的细节使用合理默认值（在假设章节中记录假设）
   6. 定义成功标准
      创建可衡量的、技术无关的结果
      包括定量指标（时间、性能、容量）和定性措施（用户满意度、任务完成）
      每个标准都必须在没有实现细节的情况下可验证
   7. 识别关键实体（如果涉及数据）
   8. 返回：成功（规范已准备好进行规划）

5. 使用模板结构将规范写入 SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保持章节顺序和标题。

6. **规范质量验证**：在撰写初始规范后，根据质量标准进行验证：

   a. **创建规范质量清单**：使用清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成清单文件，包含以下验证项目：

      ```markdown
      # 规范质量清单：[功能名称]

      **目的**：在进入规划阶段前验证规范的完整性和质量
      **创建时间**：[日期]
      **功能**：[规范链接]

      ## 内容质量

      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有强制性章节已完成

      ## 需求完整性

      - [ ] 没有 [NEEDS CLARIFICATION] 标记剩余
      - [ ] 需求可测试且明确
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（无实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 已识别边缘情况
      - [ ] 范围明确界定
      - [ ] 已识别依赖项和假设

      ## 功能就绪性

      - [ ] 所有功能需求都有明确的验收标准
      - [ ] 用户场景涵盖主要流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 规范中无实现细节泄露

      ## 笔记

      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 前更新规范
      ```

   b. **运行验证检查**：根据每个清单项目检查规范：
      - 对于每个项目，确定它是通过还是失败
      - 记录发现的特定问题（引用相关规范章节）

   c. **处理验证结果**：

      - **如果所有项目都通过**：标记清单完成并继续步骤6

      - **如果项目失败（不包括 [NEEDS CLARIFICATION]）**：
        1. 列出失败的项目和具体问题
        2. 更新规范以解决每个问题
        3. 重新运行验证直到所有项目通过（最多3次迭代）
        4. 如果3次迭代后仍失败，在清单笔记中记录剩余问题并警告用户

      - **如果剩余 [NEEDS CLARIFICATION] 标记**：
        1. 从规范中提取所有 [NEEDS CLARIFICATION: ...] 标记
        2. **限制检查**：如果存在超过3个标记，只保留最关键的3个（按范围/安全/UX影响）并对其余做出明智猜测
        3. 对于每个需要的澄清（最多3个），以以下格式向用户展示选项：

           ```markdown
           ## 问题 [N]：[主题]

           **上下文**：[引用相关规范章节]

           **我们需要知道**：[NEEDS CLARIFICATION 标记的具体问题]

           **建议答案**：

           | 选项 | 答案 | 影响 |
           |--------|--------|--------------|
           | A      | [第一个建议答案] | [这对功能意味着什么] |
           | B      | [第二个建议答案] | [这对功能意味着什么] |
           | C      | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供你自己的答案 | [解释如何提供自定义输入] |

           **你的选择**：_[等待用户响应]_
           ```

        4. **关键 - 表格格式**：确保markdown表格格式正确：
           - 使用对齐的管道和一致间距
           - 每个单元格内容周围应有空格：`| Content |` 而不是 `|Content|`
           - 标题分隔符必须至少有3个破折号：`|--------|`
           - 测试表格在markdown预览中正确渲染
        5. 按顺序编号问题（Q1、Q2、Q3 - 最多3个总计）
        6. 在等待响应之前一起展示所有问题
        7. 等待用户响应他们所有问题的选择（例如，"Q1: A, Q2: Custom - [details], Q3: B"）
        8. 通过将每个 [NEEDS CLARIFICATION] 标记替换为用户选择或提供的答案来更新规范
        9. 在所有澄清解决后重新运行验证

   d. **更新清单**：每次验证迭代后，使用当前通过/失败状态更新清单文件

7. 报告完成情况，包括分支名称、规范文件路径、清单结果，以及下一阶段的就绪状态（`/speckit.clarify` 或 `/speckit.plan`）。

**注意：**脚本在写入前会创建并检出新分支并初始化规范文件。

## 通用指南

## 快速指南

- 专注于用户需要什么**WHAT**和**为什么WHY**。
- 避免如何实现（无技术栈、API、代码结构）。
- 为业务利益相关者编写，而非开发者。
- 不要创建嵌入在规范中的任何清单。这将是一个单独的命令。

### 章节要求

- **强制性章节**：每个功能都必须完成
- **可选章节**：仅在功能相关时包含
- 当章节不适用时，完全删除它（不要留为"N/A"）

### AI生成

当从用户提示创建此规范时：

1. **做出明智猜测**：使用上下文、行业标准和常见模式填补空白
2. **记录假设**：在假设章节中记录合理的默认值
3. **限制澄清**：最多3个 [NEEDS CLARIFICATION] 标记 - 仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 有多个具有不同含义的合理解释
   - 缺乏任何合理的默认值
4. **优先考虑澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试员一样思考**：每个模糊需求都应该失败"可测试且明确"清单项目
6. **需要澄清的常见区域**（仅在没有合理默认值时）：
   - 功能范围和边界（包括/排除特定用例）
   - 用户类型和权限（如果存在多个冲突解释）
   - 安全/合规要求（在法律/财务上重要时）

**合理默认值示例**（不要询问这些）：

- 数据保留：领域的行业标准实践
- 性能目标：标准web/移动应用期望，除非另有指定
- 错误处理：用户友好的消息和适当的回退
- 认证方法：标准基于会话的或web应用的OAuth2
- 集成模式：RESTful API，除非另有指定

### 成功标准指南

成功标准必须：

1. **可衡量**：包括具体指标（时间、百分比、计数、比率）
2. **与技术无关**：不提及框架、语言、数据库或工具
3. **以用户为中心**：从用户/业务角度描述结果，而非系统内部
4. **可验证**：可以在不知道实现细节的情况下测试/验证

**好示例**：

- "用户可以在3分钟内完成结账"
- "系统支持10,000个并发用户"
- "95%的搜索在1秒内返回结果"
- "任务完成率提高40%"

**坏示例**（以实现为中心）：

- "API响应时间在200ms以下"（太技术性，使用"用户立即看到结果"）
- "数据库可以处理1000 TPS"（实现细节，使用面向用户的指标）
- "React组件高效渲染"（特定于框架）
- "Redis缓存命中率高于80%"（特定技术）
